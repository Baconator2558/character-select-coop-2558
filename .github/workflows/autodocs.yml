# This is a basic workflow to help you get started with Actions

name: Auto Documentation

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  generate-docs:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.x'
      - uses: jannekem/run-python-script-action@v1
        id: script
        with:
          fail-on-error: false
          script: |
            import re
            import os

            def parse_lua_file(lua_file_path):
            """
            Parses a Lua file to extract functions and their annotations from the _G.charSelect table.
            """
            print(f"Debug: Starting to parse Lua file: {lua_file_path}")

            if not os.path.exists(lua_file_path):
                print(f"Error: File {lua_file_path} does not exist.")
                return None

            with open(lua_file_path, 'r') as lua_file:
                lua_content = lua_file.read()

            print("Debug: Successfully read Lua file content.")

            # Remove comments from the Lua content to avoid false positives
            lua_content_no_comments = re.sub(r"--.*", "", lua_content)  # Remove single-line comments
            lua_content_no_comments = re.sub(r"--\[\[.*?\]\]", "", lua_content_no_comments, flags=re.DOTALL)  # Remove multi-line comments

            print("Debug: Removed comments from Lua content.")

            # Regex to find functions
            function_pattern = re.compile(r"function\s+(\w+)")
            functions = function_pattern.findall(lua_content_no_comments)
            print(f"Debug: Found functions: {functions}")

            # Regex to find annotations
            param_pattern = re.compile(r"---@param\s+(.+)")
            return_pattern = re.compile(r"---@return\s+(.+)")
            description_pattern = re.compile(r"---@description\s+(.+)")
            ignore_pattern = re.compile(r"---@ignore\s+(.+)")
            note_pattern = re.compile(r"---@note\s+(.+)")
            forcedoc_pattern = re.compile(r"---@forcedoc\s+(\w+)")

            # Add forcedoc functions to the list of functions
            forcedoc_functions = forcedoc_pattern.findall(lua_content)
            print(f"Debug: Found forcedoc functions: {forcedoc_functions}")
            functions.extend(forcedoc_functions)

            documentation = []

            for func in functions:
                print(f"Debug: Processing function: {func}")
                # Find the function block
                func_start = lua_content.find(f"function {func}(")
                if func_start == -1 and func not in forcedoc_functions:
                    print(f"Warning: Function {func} not found.")
                    continue

                func_end = lua_content.find("end", func_start) + 3 if func_start != -1 else -1
                func_block = lua_content[func_start:func_end] if func_start != -1 else ""
                print(f"Debug: Function block for {func}:\n{func_block}")

                # Extract annotations ABOVE the function definition, stopping at an empty line
                annotation_lines = []
                current_line_start = func_start if func_start != -1 else lua_content.find(f"---@forcedoc {func}")

                while True:
                    current_line_start = lua_content.rfind("\n", 0, current_line_start)
                    if current_line_start == -1:
                        break  # Reached the start of the file
                    line_start = current_line_start + 1
                    line_end = lua_content.find("\n", line_start)
                    line = lua_content[line_start:line_end].strip()
                    if line == "":
                        break  # Stop at the first empty line
                    annotation_lines.insert(0, line)

                annotation_block = "\n".join(annotation_lines)
                print(f"Debug: Annotation block for {func}:\n{annotation_block}")


                # Check for ignore annotation
                if ignore_pattern.search(annotation_block):
                    print(f"Debug: Function {func} is marked to be ignored. Skipping documentation.")
                    continue

                params = param_pattern.findall(annotation_block)
                returns = return_pattern.findall(annotation_block)
                description = description_pattern.findall(annotation_block)
                note = [match.lstrip(" ") if match.startswith(" ") else match for match in note_pattern.findall(annotation_block)]

                # Preserve indentation for notes
                note = [match.replace("---@note ", "") for match in note_pattern.findall(annotation_block)]

                # Build documentation entry
                doc_entry = {
                    "function": func,
                    "params": params,
                    "returns": returns,
                    "description": description[0] if description else "No description provided.",
                    "note": note,
                }
                documentation.append(doc_entry)

            print(f"Debug: Completed parsing. Documentation: {documentation}")
            return documentation
          
            print(parse_lua_file(str(os.getcwd())/o-api.lua))
      - name: Print errors
        if: steps.script.outputs.error == 'true'
        run: |
          printenv "SCRIPT_STDOUT"
          printenv "SCRIPT_STDERR"
        env:
          SCRIPT_STDOUT: ${{ steps.script.outputs.stdout }}
          SCRIPT_STDERR: ${{ steps.script.outputs.stderr }} 
